//
//  FallibleArray.swift
//  FallibleKit
//
//  Created by Brent Royal-Gordon on 11/18/14.
//  Copyright (c) 2014 Architechies. All rights reserved.
//

/// Takes an array of Fallible<T> objects and returns an array of all successful 
/// values, ignoring failures.
public func filterFailures<T>(array: [Fallible<T>]) -> [T] {
    return (anySucceeded(array) => recover { _ in Fallible(succeeded: []) }).value!
}

/// Takes an array of Fallible<T> objects and divides it into two separate arrays: 
/// one containing the values of successful operations, the other containing the 
/// errors of failed operations.
public func classifyFallibles<T>(array: [Fallible<T>]) -> (successes: [T], failures: [NSError]) {
    return reduce(array, (successes: [] as [T], failures: [] as [NSError])) { (tuple, elem) in
        if let value = elem.value {
            return (successes: tuple.successes + [value], failures: tuple.failures)
        }
        else {
            return (successes: tuple.successes, failures: tuple.failures + [elem.error!])
        }
    }
}

/// Takes an array of Fallible<T> objects and returns a successful 
/// Fallible<[T]> if all of the operations succeeded, or failure otherwise. If more 
/// than one operation failed, the error domain will be FallibleError.Domain, the 
/// code will be FallibleError.MultipleErrors.rawValue, and the list of errors 
/// may be found in FallibleError.DetailedErrorsKey.
public func allSucceeded<T>(array: [Fallible<T>]) -> Fallible<[T]> {
    let (successes, failures) = classifyFallibles(array)
    if let error = FallibleError.errorFromErrors(failures) {
        return Fallible(failed: error)
    }
    return Fallible(succeeded: successes)
}

/// Takes an array of Fallible<T> objects and returns a successful 
/// Fallible<[T]> containing the values of all successful operations, or failure 
/// if none of them succeeded. An empty array counts as a success.  If more 
/// than one operation failed, the error domain will be FallibleError.Domain, the 
/// code will be FallibleError.MultipleErrors.rawValue, and the list of errors 
/// may be found in FallibleError.DetailedErrorsKey.
public func anySucceeded<T>(array: [Fallible<T>]) -> Fallible<[T]> {
    let (successes, failures) = classifyFallibles(array)
    if successes.isEmpty {
        if let error = FallibleError.errorFromErrors(failures) {
            return Fallible(failed: error)
        }
    }
    
    return Fallible(succeeded: successes)
}

/// Enum for error codes generated by Fallible itself, not any specific Fallible 
/// version of an API.
public enum FallibleError: Int {
    /// Error domain for Fallible errors.
    public static var Domain = "FallibleKit"
    /// Key for the errors contained in a .MultipleErrors error. Note that this should  
    /// actually be interchangeable with NSDetailedErrorsKey.
    public static var DetailedErrorsKey = "NSDetailedErrors"
    
    /// Error code indicating that several different errors occurred. Check 
    /// DetailedErrorsKey for specifics.
    case MultipleErrors = 1560
    
    /// Returns a FallibleError instance if the error object represents a 
    /// FallibleError, or nil otherwise.
    public init?(error: NSError) {
        if error.domain != FallibleError.Domain {
            return nil
        }
        self.init(rawValue: error.code)
    }
    
    var localizedDescription: String {
        switch self {
        case .MultipleErrors:
            return NSLocalizedString("Several operations failed.", comment: "")
        }
    }
    
    static func errorsFromError(error: NSError?) -> [NSError] {
        if let error = error {
            if let code = FallibleError(error: error) {
                switch code {
                case .MultipleErrors:
                    return error.userInfo![DetailedErrorsKey] as [NSError]
                }
            }
            return [error]
        }
        else {
            return []
        }
    }
    
    static func errorFromErrors(errors: [NSError]) -> NSError? {
        var flatErrors = reduce(lazy(errors).map(errorsFromError), [], +)
        
        if flatErrors.count > 1 {
            let code = FallibleError.MultipleErrors
            var userInfo = [
                DetailedErrorsKey: flatErrors, 
                NSLocalizedDescriptionKey: code.localizedDescription
            ]
            return NSError(domain: Domain, code: code.rawValue, userInfo: userInfo)
        }
        else {
            return flatErrors.first
        }
    }
}
